/**
 * Script to identify and cleanup old release branches.
 *
 * Release branches are created by the release workflow and tagged with version tags.
 * Once a tag exists, the branch is no longer needed and can be deleted.
 *
 * Usage:
 *   node ./assets/ci_cleanup_release_branches.js [--days <number>] [--force]
 *
 * Options:
 *   --days <number>   Days threshold (default: 7)
 *   --force            Cleanup all branches with tags regardless of age
 *
 * Node.js 22 LTS recommended.
 */
import { execSync } from "node:child_process"
import { writeFileSync } from "node:fs"
import process from "node:process"

const CONFIG = {
  DAYS_TO_CLEANUP: 7,
  BRANCH_PREFIX: "release/v",
  BASH_SCRIPT_PREFIX: "cleanup-release-branches-",
  BASH_SCRIPT_SUFFIX: ".sh",
  MS_PER_DAY: 24 * 60 * 60 * 1000,
}
const { info, warning, critical, debug } = {
  info: (message, ...args) => console.log(message, ...args),
  warning: (message, ...args) => console.log(`\x1b[33mW: ${message}\x1b[0m`, ...args),
  critical: (message, ...args) => console.error(`\x1b[31mE: ${message}\x1b[0m`, ...args),
  debug: (message, ...args) =>
    process.env.DEBUG ? console.log(`\x1b[90mD: ${message}`, ...args, `\x1b[0m`) : undefined,
}
const ARG_DAYS = "--days"
const ARG_FORCE = "--force"
const parseArgs = () => {
  const argv = process.argv.slice(2)
  let days = CONFIG.DAYS_TO_CLEANUP
  let forceCleanup = false
  for (let i = 0; i < argv.length; i++) {
    if (argv[i] === ARG_DAYS && argv[i + 1]) {
      days = parseInt(argv[i + 1], 10)
    } else if (argv[i] === ARG_FORCE) {
      forceCleanup = true
    }
  }
  return { days, forceCleanup }
}
const checkGitHubAuthentication = () => {
  try {
    const result = execSync("gh auth status", {
      encoding: "utf-8",
      stdio: "pipe",
    })
    if (result.includes("Logged in to github.com") || result.includes("✓")) {
      info("✓ GitHub CLI authenticated")
      return true
    }
  } catch (error) {
    critical("GitHub CLI authentication failed")
    critical("Run: gh auth login")
    process.exit(1)
  }
  return false
}
const fetchRemoteBranches = () => {
  try {
    info("Fetching remote branches...")
    execSync("git fetch --prune --prune-tags origin")
    info("✓ Remote branches fetched")
  } catch (error) {
    warning("Failed to fetch remote branches")
  }
}
const getReleaseBranches = () => {
  try {
    const output = execSync("git branch -r", { encoding: "utf-8" })
    return output
      .split("\n")
      .map((line) => line.trim())
      .filter((line) => line.startsWith("origin/") && line.includes(CONFIG.BRANCH_PREFIX))
  } catch (error) {
    critical("Failed to list branches")
    process.exit(1)
  }
}
const getBranchTagAge = (branchName) => {
  try {
    const version = branchName.replace(`origin/${CONFIG.BRANCH_PREFIX}`, "")
    const tagName = `v${version}`

    // Check if tag exists
    execSync(`git rev-parse refs/tags/${tagName}`, {
      encoding: "utf-8",
      stdio: ["pipe", "pipe", "ignore"],
    })

    // Get tag creation date
    const tagDateStr = execSync(`git log -1 --format=%ct ${tagName}`, {
      encoding: "utf-8",
    }).trim()

    const tagDate = new Date(parseInt(tagDateStr, 10) * 1000)
    const now = Date.now()
    const ageDays = Math.floor((now - tagDate.getTime()) / CONFIG.MS_PER_DAY)

    return { hasTag: true, ageDays, tagName }
  } catch (error) {
    return { hasTag: false, ageDays: Infinity, tagName: null }
  }
}
const computeBranchesToDelete = (branches, daysThreshold, forceCleanup) => {
  return branches
    .map((branch) => {
      const tagInfo = getBranchTagAge(branch)
      const branchName = branch.replace("origin/", "")

      if (!tagInfo.hasTag) {
        debug(`Branch ${branchName} has no tag, skipping`)
        return null
      }

      if (forceCleanup || tagInfo.ageDays > daysThreshold) {
        info(`Marking ${branchName} for deletion (age: ${tagInfo.ageDays} days)`)
        return {
          branchName,
          tagName: tagInfo.tagName,
          ageDays: tagInfo.ageDays,
        }
      }

      debug(`Branch ${branchName} too new (age: ${tagInfo.ageDays} days)`)
      return null
    })
    .filter((item) => item !== null)
}
const generateBashScript = (branchesToDelete) => {
  const bashLines = [
    "#!/usr/bin/env bash",
    `# Autogenerated script to cleanup old release branches`,
    "set -euo pipefail",
    "",
    `echo "Starting cleanup of ${branchesToDelete.length} release branches"`,
    "",
  ]

  for (const branch of branchesToDelete) {
    bashLines.push(
      `echo "Deleting branch ${branch.branchName} (tag: ${branch.tagName}, age: ${branch.ageDays} days)"`,
      `git push origin --delete ${branch.branchName} || echo "Failed to delete ${branch.branchName}"`,
      "",
    )
  }

  if (branchesToDelete.length === 0) {
    bashLines.push('echo ""')
    bashLines.push('echo "No branches to delete."')
  }

  bashLines.push("")
  bashLines.push('echo "Release branch cleanup process completed."')

  return bashLines.join("\n")
}
const main = () => {
  try {
    const { days, forceCleanup } = parseArgs()

    info(`Days threshold: ${days}`)
    if (forceCleanup) {
      warning("Force cleanup mode enabled - will delete ALL branches with tags")
    }

    checkGitHubAuthentication()
    fetchRemoteBranches()

    const branches = getReleaseBranches()
    info(`Found ${branches.length} release branches`)

    if (branches.length === 0) {
      info("No release branches found. Exiting.")
      process.exit(0)
    }

    const branchesToDelete = computeBranchesToDelete(branches, days, forceCleanup)

    if (branchesToDelete.length === 0) {
      info(`No branches eligible for cleanup (threshold: ${days} days)`)
      process.exit(0)
    }

    info(`Found ${branchesToDelete.length} branches to delete`)

    const bashScriptContent = generateBashScript(branchesToDelete)
    const outputFileName = `${CONFIG.BASH_SCRIPT_PREFIX}${new Date().toISOString().split("T")[0]}${CONFIG.BASH_SCRIPT_SUFFIX}`

    writeFileSync(outputFileName, bashScriptContent, { mode: 0o755 })

    info(`\nBash script generated: ${outputFileName}`)
    info("\nRun it to execute cleanup, e.g.:")
    info(`\x1b[35m  ./${outputFileName}\x1b[0m\n`)
  } catch (error) {
    critical("Error:", error instanceof Error ? error.message : error, error)
    process.exit(1)
  }
}

main()
